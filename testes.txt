_______________________________ test_task_model ________________________________
self = <sqlalchemy.engine.base.Connection object at 0x7f7ad6ea4790>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f7ad6f0ff90>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext'>>
statement = 'INSERT INTO user (username, password) VALUES (?, ?)'
parameters = ('testuser', 'password')
execution_options = immutabledict({'autocommit': True, 'compiled_cache': {(<sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite obj...password', 'username'), False, False), <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f7ad6e80e50>, 4]}})
args = (<sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7f7ad6e80e50>, [{'password': 'password', 'username': 'testuser'}], <sqlalchemy.sql.dml.Insert object at 0x7f7ad6e71990>, [])
kw = {'cache_hit': symbol('CACHE_HIT')}
branched = <sqlalchemy.engine.base.Connection object at 0x7f7ad6ea4790>
yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f7ad6ea50d0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f7ad6ed2a50>
cursor = <sqlite3.Cursor object at 0x7f7ad6da8440>
fn = <function ConnectionEvents._listen.<locals>.wrap_before_cursor_execute at 0x7f7ad6ea1080>
evt_handled = False
    def _execute_context(
        self,
        dialect,
        constructor,
        statement,
        parameters,
        execution_options,
        *args,
        **kw
    ):
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        branched = self
        if self.__branch_from:
            # if this is a "branched" connection, do everything in terms
            # of the "root" connection, *except* for .close(), which is
            # the only feature that branching provides
            self = self.__branch_from
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
    
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, util.text_type(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._is_future and self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if dialect.use_setinputsizes:
            context._set_input_sizes()
    
        cursor, statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        if not context.executemany:
            parameters = parameters[0]
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                statement, parameters = fn(
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        parameters, batches=10, ismulti=context.executemany
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]"
                    % (stats,)
                )
    
        evt_handled = False
        try:
            if context.executemany:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor, statement, parameters, context
                    )
            elif not parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, statement, context
                    )
            else:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(cursor, statement, parameters, context):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, statement, parameters, context
                    )
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1900: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f7ad6f0ff90>
cursor = <sqlite3.Cursor object at 0x7f7ad6da8440>
statement = 'INSERT INTO user (username, password) VALUES (?, ?)'
parameters = ('testuser', 'password')
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f7ad6ed2a50>
    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: user.username
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:736: IntegrityError
The above exception was the direct cause of the following exception:
setup = None
    def test_task_model(setup):
        user = User(username='testuser', password='password')
        db.session.add(user)
>       db.session.commit()
tests/test_models.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:2: in commit
    ???
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1451: in commit
    self._transaction.commit(_to_root=self.future)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:829: in commit
    self._prepare_impl()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:808: in _prepare_impl
    self.session.flush()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:3444: in flush
    self._flush(objects)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:3583: in _flush
    with util.safe_reraise():
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:70: in __exit__
    compat.raise_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/compat.py:211: in raise_
    raise exception
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/session.py:3544: in _flush
    flush_context.execute()
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:456: in execute
    rec.execute(self)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:630: in execute
    util.preloaded.orm_persistence.save_obj(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:245: in save_obj
    _emit_insert_statements(
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1238: in _emit_insert_statements
    result = connection._execute_20(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1705: in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:334: in _execute_on_connection
    return connection._execute_clauseelement(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1572: in _execute_clauseelement
    ret = self._execute_context(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1943: in _execute_context
    self._handle_dbapi_exception(
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2124: in _handle_dbapi_exception
    util.raise_(
/usr/local/lib/python3.11/site-packages/sqlalchemy/util/compat.py:211: in raise_
    raise exception
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1900: in _execute_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7f7ad6f0ff90>
cursor = <sqlite3.Cursor object at 0x7f7ad6da8440>
statement = 'INSERT INTO user (username, password) VALUES (?, ?)'
parameters = ('testuser', 'password')
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7f7ad6ed2a50>
    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: user.username
E       [SQL: INSERT INTO user (username, password) VALUES (?, ?)]
E       [parameters: ('testuser', 'password')]
E       (Background on this error at: https://sqlalche.me/e/14/gkpj)
/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/default.py:736: IntegrityError

Descrição dos testes realizados pelo pytest:

1. Teste do modelo de usuário:
   - Verifica se um usuário pode ser criado e salvo no banco de dados.
   - Verifica se os atributos do usuário (id, username, password, tasks) são definidos corretamente.

2. Teste do modelo de tarefa:
   - Verifica se uma tarefa pode ser criada e salva no banco de dados.
   - Verifica se os atributos da tarefa (id, content, date_posted, user_id, author) são definidos corretamente.

3. Teste das rotas:
   - Verifica se as rotas da aplicação (about, login, register, add task, view all tasks, update task, delete task, account settings, change password) estão funcionando corretamente.
   - Verifica se as mensagens de sucesso e erro são exibidas corretamente.

4. Teste dos formulários:
   - Verifica se os formulários da aplicação (RegistrationForm, LoginForm, UpdateUserInfoForm, UpdateUserPassword, TaskForm, UpdateTaskForm) são validados corretamente.
   - Verifica se os formulários aceitam e processam os dados corretamente.

5. Teste de integração:
   - Verifica se a aplicação funciona corretamente como um todo, incluindo a interação entre os diferentes componentes (modelos, rotas, formulários).

